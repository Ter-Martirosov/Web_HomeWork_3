/*
В каждой задаче нужно оставлять короткие комментарии, которые описывают смысл вашего кода - это обязательно

Задачи:

1) Создайте функцию, которая будет вычислять объем и площадь полной поверхности куба (тоже базовая математика, иногда используется в создании анимаций).
Эта функция принимает в себя целое число со значением длины ребра куба.
Ответ выведите в формате строки, который изображен в примерах.
Если в функцию попал неправильный аргумент или вычислить значения невозможно - вернуть строку "При вычислении произошла ошибка"

Примеры:

calculateVolumeAndArea(5)  => 'Объем куба: 125, площадь всей поверхности: 150'
calculateVolumeAndArea(15)  => 'Объем куба: 3375, площадь всей поверхности: 1350'
calculateVolumeAndArea(15.5)  => 'При вычислении произошла ошибка'
calculateVolumeAndArea('15')  => 'При вычислении произошла ошибка'
calculateVolumeAndArea(-15)  => 'При вычислении произошла ошибка'

2) Напишите функцию, которая будет определять номер купе по переданному ей номеру места. Функция принимает только целое число от 1 до 36.
Если переданный аргумент не число, отрицательное или дробное - возвращается сообщение: "Ошибка. Проверьте правильность введенного номера места"
Если число 0 или больше 36, то сообщение: "Таких мест в вагоне не существует"

Пример:
getCoupeNumber(33)  => 9
getCoupeNumber(7)  => 2
getCoupeNumber(300)  => "Таких мест в вагоне не существует"
getCoupeNumber(0)  => "Таких мест в вагоне не существует"
getCoupeNumber(7.7)  => "Ошибка. Проверьте правильность введенного номера места"
getCoupeNumber(-10)  => "Ошибка. Проверьте правильность введенного номера места"
getCoupeNumber('Hello')  => "Ошибка. Проверьте правильность введенного номера места"

3) Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]


4) Разверните массив data наоборот при помощи цикла и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
ВАЖНО: нельзя использовать функцию reverse у массива

5) Напишите функцию showFamily, которая будет принимать в себя массив строк и возвращать сообщение в нужном формате.
showFamily(family)  => 'Семья состоит из: Peter Ann Alex Linda'
Имена подставляются автоматически из массива. Если массив пустой, то выводится сообщение 'Семья пуста'

6) Задания на поиск ошибок в коде
У вас есть объект с данными о ресторане. Начинающий разработчик создал несколько функций, которые работают неправильно и он не может понять почему.
Нужно исправить функции так, чтобы они давали всегда правильный результат. Все функции и объект написаны ниже

    6.1) Функция isOpen не хочет правильно работать. Что мы уже не пробовали подставлять в неё - результат все время неправильный.
    Необходимо найти причины, написать причины в виде комментария и исправить их.

    6.2) Функция isAverageLunchPriceTrue должна брать цены двух любых блюд из меню, складывать их и сравнивать с средним чеком (averageLunchPrice).
        Сейчас функция работает, но постоянно выдает неправильный результат.
        Ведь из представленного меню сумма двух любых цен всегда будет больше 20. Необходимо найти причины, написать причины в виде комментария и исправить их.

    6.3) Функция transferWaitors создана для того, чтобы копировать шаблон данных и передавать их в другой ресторан.
    Конечно, в другом ресторане будут другие блюда, другие официанты и тп. Сейчас эта функция только в начале разработки и должна менять данные про официантов.
    Но в нынешнем виде мы обнаружили, что после её запуска не только копия данных содержит новых официантов, но и основные данные! В restorantData сотрудник Alice исчезает и заменяется Mike!
    Необходимо найти причину, написать её в виде комментария и немедленно исправить, чтобы данные были разделены.
    P.S. Может показаться сложным, но задача решается очень просто, если вы помните один принцип :)


*** Усложненная задача - необязательная задача, но дающая сверху 1 балл к оценке за решение
Это одна из классических задач в программировании на формирование самых разных фигур при помощи кода.
Сейчас вам необходимо написать код, который при помощи звездочек (*) в консоли нарисует вот такую фигуру:

     *
    ***
   *****
  *******
 *********
***********

Количество звездочек можете задаватьь напрямую в коде или через дополнительную переменную - не столь важно.
(Подсказка: в конце фигуры есть перенос строки \n, который тоже учитывается в тестах.
    В КОНЦЕ КАЖДОЙ СТРОКИ НЕТ ПРОБЕЛОВ, ТОЛЬКО ПЕРЕНОС - это будет проверяться)



*/

// Задание 1

function calculateVolumeAndArea(number) {
  let volume = number ** 3 // Вычисляем объем
  let area = 6 * number ** 2 // Вычисляем площадь поверхности
  if (volume % 1 === 0 && volume > 0) {
    console.log(`Объем куба: ${volume}, площадь всей поверхности: ${area}`)
    /*
    Если объем делится на 1 без остатка, то это целое число, что и нужно нам по условию задачи. Вторая проверка - проверка на неотрицательность. Проверяем именно объем, потому что пусть число number и одинаковое, но при подсчете площади мы возводим его в квадрат, что исключает проверку на неотрицательность.
  */
  } else {
    console.log("При вычислении произошла ошибка")
  }
}

calculateVolumeAndArea(5)

// Задание 2

function getCoupeNumber(seat) {
  // seat - номер места
  if (seat % 1 === 0 && seat > 0 && seat < 37) {
    /*
      C помощью if делаем три проверки:
      1) На то, что место пассажира - целое число
      2) На то, что оно больше нуля
      3) на то, что оно меньше 37
    */
    console.log(Math.ceil(seat / 4))
    /*
      Ceil - округляет число в большую сторону. Т.к. в купе всего 4 места, значит, например, 5 место находится уже во 2 купе, а 4 в 1 купе. Это означает, что номер купе мы можем получить, если результат деления номера места на 4 будем округлять не до ближайшего целого числа, а до наибольшего.
    */
  } else {
    console.log("Ошибка. Проверьте правильность введенного номера места")
  }
}

getCoupeNumber(36)

// Задание 3 и 4
// Я объединил их, так как по условию они взаимодействуют с одним и тем же массивом

const data = [5, 10, "Shopping", 20, "Homework"]

function numberMagnifier(massive) {
  return massive.map((item) => {
    // Проходимся с помощью функции map по массиву
    if (typeof item === "string") {
      // Если элемент массива строка
      return (item = item + " - done") // То прибавляем к нему - done
    } else if (typeof item === "number") {
      // Если число
      return (item *= 2) // Удваиваем его
    }
    /*
    Можно, конечно, сделать проверку на то что элементом массива будет не число и не строка, но т.к. в условии об этом не сказано я не стал ничего добавлять :)
    */
  })
}

console.log(numberMagnifier(data))

function massReverse(massive) {
  let result = [] // Создаем пустой массив
  for (let i = massive.length - 1; i >= 0; i--) {
    // Проходимся по введенному массиву начиная с конца
    result.push(massive[i]) // Записываем элементы с конца в пустой массив
  }
  return result // Возвращаем массив, обратный тому, что был дан на вход функции
}

console.log(massReverse(data))

// Задание 5

const family = ["Peter", "Ann", "Alex", "Linda"]

function showFamily(family) {
  if (family.length > 0) {
    // Проверяем есть ли в массиве, хотя бы один элемент
    console.log(`Семья состоит из: ${family.join(" ")}`) // Если есть, то обьединяем все эелементы в строку и подставляем в предложение
  } else {
    console.log("Семья пуста") // Если нет, то по условию задачи выводим "Семья пуста"
  }
}

showFamily(family)

// Задание 6
const restorantData = {
  menu: [
    {
      name: "Salad Caesar",
      price: "14$",
    },
    {
      name: "Pizza Diavola",
      price: "9$",
    },
    {
      name: "Beefsteak",
      price: "17$",
    },
    {
      name: "Napoleon",
      price: "7$",
    },
  ],
  waitors: [
    { name: "Alice", age: 22 },
    { name: "John", age: 24 },
  ],
  averageLunchPrice: "20$",
  openNow: true,
}

function isOpen(prop) {
  let answer // Js имеет динамическую типизацию, так что не обязательно при обьявлении переменной давать ей тип
  prop ? (answer = "Открыто") : (answer = "Закрыто")
  /*
  Неправильная логика работы с оператором ? т.к. часть между ? и : выполняется, если условие перед ? равно true. Поскольку аргумент openNow (очевидно из названия) говорит о том, открыт ресторан или нет, логично будет, что при prop = true, answer = "Открыто".
  */
  return answer // Неправильно была написана переменная (aswer)
}

console.log(isOpen(restorantData.openNow))

function isAverageLunchPriceTrue(fDish, sDish, average) {
  const fprice = +fDish.price.slice(0, fDish.price.length - 1),
    sprice = +sDish.price.slice(0, sDish.price.length - 1)
  avprice = +average.slice(0, average.length - 1)
  /*
  Функция выводила неправильный результат, т.к. при сложении числа и строки (+fDish.price.slice(0, -1) в изначальной версии была числом (14) и складывалась с sDish.price, которая была строкой('9$')) результат неправильно сравнивался с средней ценой (average тоже была строкой ('20$')). Я привел функцию к корректной работе с помощью того, что в начале все 3 переменные (Цена двух случайных блюд и средняя цена) приводятся к типу number и уже потом сравниваются
  */
  if (fprice + sprice < avprice) {
    return "Цена ниже средней"
  } else {
    return "Цена выше средней"
  }
}

console.log(
  isAverageLunchPriceTrue(
    restorantData.menu[0],
    restorantData.menu[1],
    restorantData.averageLunchPrice
  )
)

function transferWaitors(data) {
  const copy = JSON.parse(JSON.stringify(data))
  // const copy = Object.assign({}, data)

  /*
  Ошибка появляется из-за того, что метод Object.assign() производит поверхностное копирование (т.е. копирует ссылку на объект, а не сам объект). На одном из прошлых занятий мы разбирали, что можно произвести глубокое копирование объекта с помощью перевода оного в формат JSON и обратно, что я и сделал выше.
  */
  copy.waitors[0] = { name: "Mike", age: 32 }
  return copy
}

console.log(transferWaitors(restorantData))

// Задание со звездочкой

function starTask(num) {
  let height = num // Определяем высоту фигуры
  let starNumber = [1] // Вводим массив в котором хранится кол-во звезд на каждой строке сверху вниз
  for (let i = 0; i < height - 1; i++) {
    // с помощью цикла заносим в массив значения для нужной высоты, если высота равна 1 массив не изменяется
    starNumber.push(starNumber[i] + 2) // если высота больше единицы, на каждой следующей строчке звезд ровно на 2 штуки больше
  }
  let it = 0 // вспомогательная переменная, которая определяет на какой строке мы находимся
  for (let i = height - 1; i >= 0; i--) {
    // i в цикле определяет кол-во пробелов в строке
    console.log(" ".repeat(i) + "*".repeat(starNumber[it]))
    it++
  }
}

starTask(4)
